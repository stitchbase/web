import{J as S,u as j,K as h,C as E,L as R,M as F,e as H,N as b,O as U,P as L,B as z,Q as G,R as I,S as J,f as Q,U as W}from"./DTI8ayNm.js";const q={trailing:!0};function X(e,a=25,l={}){if(l={...q,...l},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let u,t,c=[],s,v;const _=(D,n)=>(s=Y(e,D,n),s.finally(()=>{if(s=null,l.trailing&&v&&!t){const y=_(D,v);return v=null,y}}),s);return function(...D){return s?(l.trailing&&(v=D),s):new Promise(n=>{const y=!t&&l.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const f=l.leading?u:_(this,D);for(const m of c)m(f);c=[]},a),y?(u=_(this,D),n(u)):c.push(n)})}}async function Y(e,a,l){return await e.apply(a,l)}const Z=Symbol.for("nuxt:client-only"),$=e=>e==="defer"||e===!1;function A(...e){var m;const a=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&typeof e[0]!="object"&&!(typeof e[0]=="function"&&typeof e[1]=="function")&&e.unshift(a);let[l,u,t={}]=e;const c=S(()=>F(l));if(typeof c.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=j();t.server??(t.server=!0),t.default??(t.default=x),t.getCachedData??(t.getCachedData=V),t.lazy??(t.lazy=!1),t.immediate??(t.immediate=!0),t.deep??(t.deep=h.deep),t.dedupe??(t.dedupe="cancel"),t._functionName,s._asyncData[c.value];const v=t.getCachedData(c.value,s,{cause:"initial"});(m=s._asyncData[c.value])!=null&&m._init||(s._asyncData[c.value]=B(s,c.value,u,t,v));const _=s._asyncData[c.value];_._deps++;const D=()=>s._asyncData[c.value].execute({cause:"initial",dedupe:t.dedupe}),n=t.server!==!1&&s.payload.serverRendered;{let r=function(o){const d=s._asyncData[o];d!=null&&d._deps&&(d._deps--,d._deps===0&&(d==null||d._off()))};const i=I();if(i&&n&&t.immediate&&!i.sp&&(i.sp=[]),i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;J(()=>{o.forEach(d=>{d()}),o.splice(0,o.length)}),Q(()=>o.splice(0,o.length))}const P=i&&(i._nuxtClientOnly||W(Z,!1));n&&s.isHydrating&&(_.error.value||v!=null)?(_.pending.value=!1,_.status.value=_.error.value?"error":"success"):i&&!P&&(s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?i._nuxtOnBeforeMountCbs.push(D):t.immediate&&D();const C=G();if(t.watch){const o=E(t.watch,()=>{_._execute({cause:"watch",dedupe:t.dedupe})},{flush:"post"});C&&R(()=>o())}const M=E(c,(o,d)=>{var w,O;const T=((w=s._asyncData[d])==null?void 0:w.data.value)!==h.value;d&&r(d),(O=s._asyncData[o])!=null&&O._init||(s._asyncData[o]=B(s,o,u,t,t.getCachedData(o,s,{cause:"initial"}))),s._asyncData[o]._deps++,(t.immediate||T)&&s._asyncData[o].execute({cause:"initial",dedupe:t.dedupe})},{flush:"sync"});C&&R(()=>{M(),r(c.value)})}const y={data:g(()=>{var r;return(r=s._asyncData[c.value])==null?void 0:r.data}),pending:g(()=>{var r;return(r=s._asyncData[c.value])==null?void 0:r.pending}),status:g(()=>{var r;return(r=s._asyncData[c.value])==null?void 0:r.status}),error:g(()=>{var r;return(r=s._asyncData[c.value])==null?void 0:r.error}),refresh:(...r)=>s._asyncData[c.value].execute(...r),execute:(...r)=>s._asyncData[c.value].execute(...r),clear:()=>N(s,c.value)},f=Promise.resolve(s._asyncDataPromises[c.value]).then(()=>y);return Object.assign(f,y),f}function g(e){return S({get(){var a;return(a=e())==null?void 0:a.value},set(a){const l=e();l&&(l.value=a)}})}function N(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=h.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=h.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}function K(e,a){const l={};for(const u of a)l[u]=e[u];return l}function B(e,a,l,u,t){var y;(y=e.payload._errors)[a]??(y[a]=h.errorValue);const c=u.getCachedData!==V,s=l,v=u.deep?H:b,_=t!=null,D=e.hook("app:data:refresh",async f=>{(!f||f.includes(a))&&await n.execute({cause:"refresh:hook"})}),n={data:v(_?t:u.default()),pending:b(!_),error:U(e.payload._errors,a),status:b("idle"),execute:(f={})=>{if(e._asyncDataPromises[a]){if($(f.dedupe??u.dedupe))return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if(f.cause==="initial"||e.isHydrating){const r=f.cause==="initial"?t:u.getCachedData(a,e,{cause:f.cause??"refresh:manual"});if(r!=null)return e.payload.data[a]=n.data.value=r,n.error.value=h.errorValue,n.status.value="success",Promise.resolve(r)}n.pending.value=!0,n.status.value="pending";const m=new Promise((r,i)=>{try{r(s(e))}catch(P){i(P)}}).then(async r=>{if(m.cancelled)return e._asyncDataPromises[a];let i=r;u.transform&&(i=await u.transform(r)),u.pick&&(i=K(i,u.pick)),e.payload.data[a]=i,n.data.value=i,n.error.value=h.errorValue,n.status.value="success"}).catch(r=>{if(m.cancelled)return e._asyncDataPromises[a];n.error.value=L(r),n.data.value=z(u.default()),n.status.value="error"}).finally(()=>{m.cancelled||(n.pending.value=!1,delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=m,e._asyncDataPromises[a]},_execute:X((...f)=>n.execute(...f),0,{leading:!0}),_default:u.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{D(),n._init=!1,c||(N(e,a),n.execute=()=>Promise.resolve(),n.data.value=h.value)}};return n}const x=()=>h.value,V=(e,a,l)=>{if(a.isHydrating)return a.payload.data[e];if(l.cause!=="refresh:manual"&&l.cause!=="refresh:hook")return a.static.data[e]};export{A as u};
